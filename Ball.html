<html>
    <head>
        <meta charset="utf-8">
        <title>Labyrinth Ball Game</title>
        <style>
            body { margin: 0; }
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
        <script src="js/ammo.js"></script>
		<div id="info">Description</div>
	
        <script>
		//TODO 
		// - sound on /off
		// - score
		// - angle level
		// - strart bouton => sound

		
		//substract 3d
		//http://learningthreejs.com/blog/2011/12/10/constructive-solid-geometry-with-csg-js/
		
		
		//https://medium.com/@bluemagnificent/intro-to-javascript-3d-physics-using-ammo-js-and-three-js-dd48df81f591
		//http://lo-th.github.io/Ammo.lab/#basketball
		//https://stemkoski.github.io/Three.js/Collision-Detection.html
		//file:///D:/Utilisateurs/Nous/Desktop/Dev/amo1/ammo.js-master/examples/webgl_demo_vehicle/index.html
		//http://webmaestro.fr/collisions-detection-three-js-raycasting/

		//terrain
		//http://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html
		//https://grahamweldon.com/post/2012/01/3d-terrain-generation-with-three.js/
		//http://kripken.github.io/ammo.js/examples/webgl_demo_terrain/index.html

		//map
		//http://learningthreejs.com/blog/2011/09/14/lets-make-a-3D-game-map-editor/

		//Physijs/
		//https://gamedevelopment.tutsplus.com/tutorials/creating-a-simple-3d-physics-game-using-threejs-and-physijs--cms-29453
		//https://chandlerprall.github.io/Physijs/


		//compound:
		//https://github.com/kripken/ammo.js/blob/master/bullet/Demos/ConstraintDemo/ConstraintDemo.cpp
		//https://gist.github.com/erwincoumans/b8a110b5c228b378161068cd25fa7d2c

        //variable declaration section
			
			
			var holes=[ {x:15.5,y:9.5,l:"1"},	{x:10.75,y:9.5,l:"2,22"},	{x:3,y:3,l:"3"},		{x:6,y:10,l:"4,5"},			{x:2.5,y:25.5,l:"6,9"},
						{x:2,y:39.5,l:"10"},	{x:6,y:35.5,l:"11"},	 	{x:5.5,y:44,l:"12"},	{x:10.75,y:40.75,l:"13"},	{x:15.25,y:46.75,l:"14,33"},
						{x:15.5,y:34.5,l:"15"},	{x:11.25,y:30.5,l:"8,16"},	{x:16,y:25.5,l:"17,20"},{x:11,y:22,l:"7,21"},		{x:14.75,y:16.5,l:"23"},
						{x:20.25,y:34.5,l:"18,31"},{x:21,y:17.75,l:"19"},	{x:30.5,y:6.85,l:"24,26"},{x:25.75,y:17,l:"25,28"},{x:31,y:26,l:"27,29,49"},
						{x:30.5,y:38.5,l:"30,36"},{x:25.25,y:43.75,l:"32,34"},{x:35.5,y:47.75,l:"35,39"},{x:35.75,y:42.5,l:"37"},{x:35.35,y:34.85,l:"38,48"},
						{x:35.85,y:18,l:"50"},{x:36.5,y:12,l:"54"},{x:36.75,y:2.75,l:"55"},{x:46.5,y:2.25,l:"56"},{x:52.5,y:2,l:"57"},{x:56.5,y:6.75,l:"58,60"},
						{x:46.5,y:12.25,l:"53"},{x:52,y:19.5,l:"45,59"},{x:45.75,y:21.5,l:"46,52"},{x:40.65,y:22.75,l:"51"},{x:45.75,y:38.5,l:"41,47"},
						{x:51,y:37,l:"42"},{x:51,y:46.25,l:"40"},{x:55.5,y:43,l:"43"},{x:55.5,y:32.5,l:"44"}
						
						];
			var finish={x:56.5,y:27.5,l:"Finish"};
			
            let physicsWorld, scene, camera, controls,renderer, rigidBodies = [];
            let colGroupPlane = 1, colGroupRedBall = 2, colGroupGreenBall = 4

			let posOrigin = {x: 2, y: 10, z: -23};
			var woodcolor=0x521C1A;
			var materialWood;
			var listener;
			var sound;
			var soundEnabled=false;
			
			var groupGround;
			var compoundShapeGround;
			var BlockBodyGround;
			
			var groupGroundRing;
			var compoundShapeRing;
			var BlockBodyRing;
			
			var groupGroundBox;
			var compoundShapeBox;
			var BlockBodyBox;
			
			var ball;
			var bodyBall; 
			var ballRadius=1;
			var caster = new THREE.Raycaster();
			
			var previousFrotte=false;
			var lastBong=Date.now();
			var rolling=false;
			var inhole=false;
			
			var AngleZ=0;
			var AngleX=0;

			document.addEventListener("keydown", onDocumentKeyDown, false);
			function onDocumentKeyDown(event) {
				var keyCode = event.which;
				//var delta=0.005;
				var delta=0.02;
				//console.log("key pressed " +keyCode);
				if (keyCode == 38) {
						if(AngleX>-0.078)
							rotateX(-delta);
				} else if (keyCode == 40) {
						if(AngleX<0.078)
							rotateX(delta);
				} else if (keyCode == 39) {
						if(AngleZ>-0.078)
							rotateZ(-delta);
				} else if (keyCode == 37) {
						if(AngleZ<0.078)
							rotateZ(delta);
				} else if (keyCode == 32) {
					//blockPlane.position.set(0, 0, 0);
				
				} else if (keyCode == 65) {//a
					console.log("apply force");
					//apply force
					var relativeForce = new Ammo.btVector3(100,0,100);
					//btTransform* boxTrans;
					//boxRigidBody->getMotionState()->getWroldTransform(boxTrans);
					//btVector3 correctedForce = (boxTrans * relativeForce) - boxTrans.getOrigin();
					bodyBall.applyCentralForce(relativeForce);
				}else if (keyCode == 82) {//r
					console.log("restart");
					AngleZ=0;
					AngleX=0;
					rotateRingX();
					rotateGroundXZ();
					//bodyBall.position.x = posOrigin.x;//, posOrigin.y, posOrigin.z ) );
					let transform = new Ammo.btTransform();
					transform.setIdentity();
					transform.setOrigin( new Ammo.btVector3( posOrigin.x, posOrigin.y, posOrigin.z ) );
					//transform.setRotation( new Ammo.btQuaternion( AngleX, 0, AngleZ, 1 ) );
							
					bodyBall.setWorldTransform(transform);
					bodyBall.setLinearVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
					bodyBall.setAngularVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
					
					rolling=false;
					inhole=false;
				
				}else if (keyCode == 83) {//s
				
					console.log("sound");
							// create a global audio source
					sound = new THREE.Audio( listener );

					// load a sound and set it as the Audio object's buffer
					var audioLoader = new THREE.AudioLoader();
					audioLoader.load( 'sounds/Ball_Bounce.wav', function( buffer ) {
						sound.setBuffer( buffer );
						sound.setLoop( false );
						sound.setVolume( 1 );
						//sound.play();
						soundEnabled=true;
					});
				}
			};




			function rotateZ(deltaZ) {
				//console.log("key pressedZ:" +AngleX+", "+AngleZ);
				AngleZ=AngleZ+deltaZ;
				rotateGroundXZ();
				
			}

			function rotateX(deltaX) {
				//console.log("key pressedX:" +AngleX+", "+AngleZ);
				AngleX=AngleX+deltaX;
				rotateRingX();
				rotateGroundXZ();
			}
			function rotateGroundXZ() {
					let pos = {x: 0, y: 0, z: 0};
					let transform = new Ammo.btTransform();
					transform.setIdentity();
					transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
					transform.setRotation( new Ammo.btQuaternion( AngleX, 0, AngleZ, 1 ) );
							
					BlockBodyGround.setWorldTransform(transform);
					BlockBodyGround.setLinearVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
					BlockBodyGround.setAngularVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
				
					let p = transform.getOrigin();
					let q = transform.getRotation();
					groupGround.position.set( p.x(), p.y(), p.z() );
					groupGround.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			}

			function rotateRingX() {
					let pos = {x: 0, y: 0, z: 0};
					let transform = new Ammo.btTransform();
					transform.setIdentity();
					transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
					transform.setRotation( new Ammo.btQuaternion( AngleX, 0, 0, 1 ) );
							
					BlockBodyRing.setWorldTransform(transform);
					BlockBodyRing.setLinearVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
					BlockBodyRing.setAngularVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
				
					let p = transform.getOrigin();
					let q = transform.getRotation();
					groupGroundRing.position.set( p.x(), p.y(), p.z() );
					groupGroundRing.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			}


			
            //Ammojs Initialization
            Ammo().then(start)

            function start (){


                tmpTrans = new Ammo.btTransform();

                setupPhysicsWorld();
				setupGraphics();
				
				groupGround = new THREE.Group();
				groupGroundRing= new THREE.Group();
				groupGroundBox= new THREE.Group();
                compoundShapeGround = new Ammo.btCompoundShape();
				compoundShapeRing = new Ammo.btCompoundShape();
				compoundShapeBox = new Ammo.btCompoundShape();
				
				
				
				var loader = new THREE.TextureLoader();
				var texture1 =loader.load('img/Background.jpg');
				console.log("texture="+texture1);
				texture1.wrapS = texture1.wrapT = THREE.RepeatWrapping;
				texture1.repeat.set( 1/60, -1/50 );
				var materialBase = new THREE.MeshBasicMaterial( {map: texture1 } );
				var texture2 =loader.load('img/wood.jpg');
				materialWood = new THREE.MeshBasicMaterial( {map: texture2 } );
				
				
				var floorGeometry = new THREE.PlaneGeometry( 500, 500, 20, 20 );
				floorGeometry.rotateX( - Math.PI / 2 );
				
				var floorTexture = loader.load( 'img/wood-floorboards-texture.jpg' );
				floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
				floorTexture.repeat.set(3, 3);
				var floorMaterial = new THREE.MeshBasicMaterial({map: floorTexture});
				var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
				floorMesh.translateY(-18);
				scene.add( floorMesh );
				
				//sky
				
				var path = "img/sand/";
				var format = '.png';
				var urls = [
					path + 'right' + format,
					path + 'left' + format,
					path + 'top' + format,
					path + 'bottom' + format,
					path + 'back' + format,
					path + 'front' + format
				];
				 
				var reflectionCube = THREE.ImageUtils.loadTextureCube(urls);
				reflectionCube.format = THREE.RGBFormat;
				 
				var shader = THREE.ShaderLib[ "cube" ];
				shader.uniforms[ "tCube" ].value = reflectionCube;
				 
				var material = new THREE.ShaderMaterial( {
					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: shader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				});
				 
				mesh = new THREE.Mesh(new THREE.BoxGeometry(1000, 1000, 1000), material);
				scene.add(mesh);


				
				createGround(materialBase);
				createWalls();
				scene.add( groupGround );
				scene.add( groupGroundRing);
				scene.add( groupGroundBox);
								
				var mass=0;
				let localInertia = new Ammo.btVector3( 0, 0, 0 );
				compoundShapeGround.calculateLocalInertia(mass,localInertia);
				let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, 0, compoundShapeGround, localInertia );
				BlockBodyGround = new Ammo.btRigidBody( rbInfo );
			  
				BlockBodyGround.setFriction(.1);
				BlockBodyGround.setRestitution(.8);
				BlockBodyGround.setDamping(0.2, 0.2);
				BlockBodyGround.setCollisionFlags( 1 );// 0 is static, 1 is dynamic, 2 is kinematic
				BlockBodyGround.setActivationState( 4 );//never sleep

				physicsWorld.addRigidBody( BlockBodyGround, colGroupPlane, colGroupRedBall );
				
				
				createRing();
				
				
				
				

				
				createBox();
				
				
                createBall();
                //createMaskBall();

                renderFrame();
			
            }

            function setupPhysicsWorld(){

                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -20, 0));//2g to speed up the gameplay

            }
			/*
			//print positions of all objects
		for (int j = physicsWorld->getNumCollisionObjects() - 1; j >= 0; j--)
		{
			btCollisionObject* obj = physicsWorld->getCollisionObjectArray()[j];
			btRigidBody* body = btRigidBody::upcast(obj);
			btTransform trans;
			if (body && body->getMotionState())
			{
				body->getMotionState()->getWorldTransform(trans);
			}
			else
			{
				trans = obj->getWorldTransform();
			}
			printf("world pos object %d = %f,%f,%f\n", j, float(trans.getOrigin().getX()), float(trans.getOrigin().getY()), float(trans.getOrigin().getZ()));
		}
			*/




/*
            function createBlock(pos,scale){
                
                //let pos = {x: 0, y: 0, z: 0};
                //let scale = {x: 50, y: 2, z: 50};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 0;

                //threeJS Section
				var blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa0afa4}));
                blockPlane.position.set(pos.x, pos.y, pos.z);
                blockPlane.scale.set(scale.x, scale.y, scale.z);
				const quaternion = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w);
				blockPlane.applyQuaternion(quaternion); // Apply Quaternion
                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;
				groupGround.add( blockPlane );

                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                //let motionState = new Ammo.btDefaultMotionState( transform );
                var colShapePlane = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
                colShapePlane.setMargin( 0.05 );
                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShapePlane.calculateLocalInertia( mass, localInertia );
				
				//let transform2 = new Ammo.btTransform();
				//transform2.setIdentity();
				//transform2.setOrigin(new Ammo.btVector3(0, 0, 0));
				compoundShapeGround.addChildShape(transform, colShapePlane);
				
            }
*/



	function createRing()
	{
		var offset=2.5;
		var dy=5;
		let mass = 0;
		
		createBlock2({x: 0, y: 2, z: -26-offset},{x: 62+offset*2, y: dy, z: 2},null,true,2);
		createBlock2({x: 0, y: 2, z: 26+offset},{x: 62+offset*2, y: dy, z: 2},null,true,2);
		createBlock2({x: -31-offset, y: 2, z: 0},{x: 2, y: dy, z: 54+offset*2},null,true,2);
		createBlock2({x: 31+offset, y: 2, z: 0},{x: 2, y: dy, z: 54+offset*2},null,true,2);
		
		let localInertia = new Ammo.btVector3( 0, 0, 0 );
		compoundShapeRing.calculateLocalInertia(mass,localInertia);
		let rbInfoRing = new Ammo.btRigidBodyConstructionInfo( mass, 0, compoundShapeRing, localInertia );
		BlockBodyRing = new Ammo.btRigidBody( rbInfoRing );
	  
		BlockBodyRing.setFriction(.1);
		BlockBodyRing.setRestitution(.8);
		BlockBodyRing.setDamping(0.2, 0.2);
		BlockBodyRing.setCollisionFlags( 1 );// 0 is static, 1 is dynamic, 2 is kinematic
		BlockBodyRing.setActivationState( 4 );//never sleep

		physicsWorld.addRigidBody( BlockBodyRing, colGroupPlane, colGroupRedBall );
			
	}
	
	function createBox()
	{
		var offset=5;
		var dy=21;
		let mass = 0;
		createBlock2({x: 0, y: -6, z: -26-offset},{x: 62+offset*2, y: dy, z: 2},null,true,3);
		//createBlock2({x: 0, y: -6, z: 26+offset},{x: 62+offset*2, y: dy, z: 2},null,true,3);//devant
		createBlock2({x: -31-offset, y: -6, z: 0},{x: 2, y: dy, z: 54+offset*2},null,true,3);// agauche
		createBlock2({x: 31+offset, y: -6, z: 0},{x: 2, y: dy, z: 54+offset*2},null,true,3);//a droite
		
		
		createBlock2({x: -2, y: -6, z: 26+offset},{x: 62+offset*2-4, y: dy, z: 2},null,true,3);//devant gauche
		createBlock2({x: 31+2, y: -6+2, z: 26+offset},{x: 4, y: dy-4, z: 2},null,true,3);//devant haut droit
		createBlock2({x: 31+2, y: -dy+5, z: 26+offset+2.5},{x: 4, y: 1, z: 2+2},null,true,3);//devant bas
		
		createBlock2({x: 31+2, y: -dy+5, z: 26+offset+2.5},{x: 7, y: 1, z: 2+2},null,true,3);//devant bas
		
		createBlock2({x: 31+2, y: -dy+5+1, z: 26+offset+4},{x: 6, y: 1, z: 1},null,true,3);//devant bas barriere
		createBlock2({x: 31+2-3, y: -dy+5+1, z: 26+offset+2.5},{x: 1, y: 1, z: 4},null,true,3);//devant bas gauche barriere
		createBlock2({x: 31+2+3, y: -dy+5+1, z: 26+offset+2.5},{x: 1, y: 1, z: 4},null,true,3);//devant bas droite barriere
		
		createBlock3({x: 0, y: -12, z:  0},{x: 62+offset*2, y: 1, z: 54+offset*2},{x: 0.025, y: 0.0, z: -0.025, w: 1}, null, true,3);
		
		
		
		
		
		let localInertia = new Ammo.btVector3( 0, 0, 0 );
		compoundShapeBox.calculateLocalInertia(mass,localInertia);
		let rbInfoRing = new Ammo.btRigidBodyConstructionInfo( mass, 0, compoundShapeBox, localInertia );
		BlockBodyBox = new Ammo.btRigidBody( rbInfoRing );
	  
		BlockBodyBox.setFriction(.1);
		BlockBodyBox.setRestitution(.8);
		BlockBodyBox.setDamping(0.2, 0.2);
		BlockBodyBox.setCollisionFlags( 1 );// 0 is static, 1 is dynamic, 2 is kinematic
		BlockBodyBox.setActivationState( 4 );//never sleep

		physicsWorld.addRigidBody( BlockBodyBox, colGroupPlane, colGroupRedBall );
		
	}

		function createWalls()
		{
			//createBlock( {x: 0, y: 0, z: 0},   {x: 50, y: 2, z: 50});
			createBlock({x: 0, y: 2, z: -26},{x: 62, y: 6, z: 2});
			createBlock({x: 0, y: 2, z: 26},{x: 62, y: 6, z: 2});
			createBlock({x: -31, y: 2, z: 0},{x: 2, y: 6, z: 54});
			createBlock({x: 31, y: 2, z: 0},{x: 2, y: 6, z: 54});
				
			createWall_y(4,-14,23);//grand vertical pres du start
			createWall_x(-3.5,-21,16);//grand horizontal sous le start
			createWall_y(-11,-18.5,5.5);//au bout du precedent
			createWall_y(-16,-23,5);//en face du start
			createWall_y(-16.5,-16,4);//en dessous du precedent
			createWall_y(-21.5,-18.5,4);//entre 2 et 4
			createWall_x(-28,-19,4.5);//sous le 3
			createWall_x(-28,-9.5,4.5);//en desous du precedent
			createWall_y(-21,-8.75,8);//entre 5 et 22
			createWall_x(-23,-5.25,5);//pres du 7
			createWall_y(-25,2,4);//pres du 6 et du 9
			createWall_y(-21,2,4);//au dessus du 8
			
			createWall_x(-24,8,5);//au dessus du 11
			createWall_y(-22,14,13);//en dessous du 8
			
			createWall_y(-17.25,22.5,5);//a gauche du 33
			createWall_y(-16.5,15.5,3);//a droite du 13
			createWall_y(-16.25,1,7);//a gauche du 17
			createWall_y(-17,-8,2);//en haut à droite du 21
			
			
		}
/*
		function createWallExtrude()
		{
			var shape = new THREE.Shape();
			//...define your shape
			shape.moveTo( 10,10 );
			shape.lineTo( 10, 12 );
			shape.absarc(10.25, 12, 0.25, 0, Math.PI*2 , false);
			
			//shape.lineTo( 10.5,12 );
			shape.lineTo( 10.5,10 );
			shape.lineTo( 10,10 );
			
			const extrudeSettings = {
			  steps: 2,
			  depth: 30,
			  bevelEnabled: false,
			  bevelThickness: 1,
			  bevelSize: 1,
			  bevelSegments: 2,
			};
			
			var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
			
			
			var mesh = new THREE.Mesh( geometry, materialWood) ;
			mesh.rotation.x= THREE.Math.degToRad( 0 );
			mesh.position.x=-30;
			mesh.position.z=-25;
			mesh.position.y=5;
			
			mesh.castShadow = true;
            mesh.receiveShadow = true;
			//scene.add( mesh );
			groupGround.add( mesh );
			
		}
		*/
		function createWall_x(pos_x,pos_z,len)
		{
			createBlock2({x: pos_x, y: 2, z: pos_z},{x: len, y: 1, z: 1},0xa0afa4,true,1);
		}
		
		function createWall_y(pos_x,pos_z,len)
		{
			createBlock2({x: pos_x, y: 2, z: pos_z},{x: 1, y: 1, z: len},0xa0afa4,true,1);
		}
		
		function createBlock(pos,scale)
		{
			createBlock2(pos,scale,null,true,1);
		}
		function createBlock2(pos,scale, color, create3js,group)
		{
			let quat = {x: 0, y: 0, z: 0, w: 1};
			createBlock3(pos,scale,quat, color, create3js,group);
		}
	    function createBlock3(pos,scale,quat, color, create3js,group)
		{
           
            let mass = 0;

			if(create3js==true)
			{
				//threeJS Section
				var block1;
				if(color==null)
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), materialWood);
				else
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: color}));
					
					block1.position.set(pos.x, pos.y, pos.z);
					block1.scale.set(scale.x, scale.y, scale.z);
					const quaternion = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w);
					block1.applyQuaternion(quaternion); // Apply Quaternion
					block1.castShadow = true;
					block1.receiveShadow = true;
					if(group==1)
						groupGround.add( block1 );
					if(group==2)
						groupGroundRing.add( block1 );
					if(group==3)
						groupGroundBox.add( block1 );
			}
			//Ammojs Section
			let transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
			//let motionState = new Ammo.btDefaultMotionState( transform );
			var colShape1 = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
			colShape1.setMargin( 0.05 );
			let localInertia = new Ammo.btVector3( 0, 0, 0 );
			colShape1.calculateLocalInertia( mass, localInertia );
				
			//let transform2 = new Ammo.btTransform();
			//transform2.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			if(group==1)
				compoundShapeGround.addChildShape(transform, colShape1);
			if(group==2)	
				compoundShapeRing.addChildShape(transform, colShape1);
			if(group==3)	
				compoundShapeBox.addChildShape(transform, colShape1);
			
            }

		
		function AddHole(shape,hole,radius){

			var ox=hole.x;
			var oy=hole.y;
			
			var circleTri = new THREE.Shape();
			var circle = new THREE.Shape();
			var segments = 32;
			var theta, x, y;
			for (var i = 0; i < segments; i++) {
				theta = ((i + 1) / segments) * Math.PI * 2.0;
				x = radius * Math.cos(theta);
				y = radius * Math.sin(theta);
				if (i == 0) {
					circle.moveTo(x+ox, y+oy);
				} else {
					circle.lineTo(x+ox, y+oy);
				}
			}
			shape.holes.push( circle );
		}

	function CreateSubBlockDemo(x,y,z,dx,dy,dz,color)
	{
		createBlock2({x: x, y: 0, z: z},{x: dx, y: 2, z: dz}, color,false,1);
		//createBlock2({x: x, y: 1, z: z},{x: dx, y: 2, z: dz}, color,true);
	}
	function CreateBlockDemo(holes)
	{
		var Column=[];
		var h;
		//var diam=2.3;
		var diam=2.45;
		var radius=diam/2.0;
		var dx=60;
		var dy=50;
		var dx_2=30;
		var dy_2=25;
		
		/*
		for(h=0;h<holes.length;h++)
		//h=14;
		{
			var block1;
			block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa00f04}));
			block1.position.set(holes[h].x-dx_2, 1, holes[h].y-dy_2);
			block1.scale.set(diam, 1, diam);
			//groupGround.add( block1 );
		}
		*/
		//recherche vers le haut
		for(h=0;h<holes.length;h++)
		//h=14;
		{
			var y=0;
			var sideL=false;
			var sideR=false;
			var top=true;
			var maxX=0;
			var minX=45555;
			
			for(h2=0;h2<holes.length;h2++)
			{
				if(h!=h2)
				{
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+diam)&& (holes[h2].y+diam>holes[h].y))//en cube en haut dand le fuseau a droite
					{
						top=false;
					}
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+diam)&& (holes[h2].y+diam<holes[h].y))//en cube en haut dand le fuseau a droite
					{
						if(holes[h2].x>maxX)
						{
							maxX=holes[h2].x;
							sideR=true;
						}
						if(holes[h2].y+diam>y)
						{
							y=holes[h2].y+diam;
							//console.log("j'ai UP+1"+y);
						}
					}
					if((holes[h2].x+diam>=holes[h].x)&&(holes[h2].x+diam<=holes[h].x+diam)&& (holes[h2].y+diam>holes[h].y))//en cube en haut dand le fuseau a droite
					{
						top=false;
					}
					if((holes[h2].x+diam>=holes[h].x)&&(holes[h2].x+diam<=holes[h].x+diam)&& (holes[h2].y+diam<holes[h].y))//en cube en haut dans le fuseau a gauche
					{
						if(holes[h2].x<minX)
						{
							minX=holes[h2].x;
							sideL=true;
						}
						if(holes[h2].y+diam>y)
						{
							y=holes[h2].y+diam;
						//	console.log("j'ai UP-1 "+y);
						}
					}
				}
			}
			CreateSubBlockDemo(holes[h].x-dx_2, 1, (holes[h].y-y)/2+y -dy_2-radius,diam, 1, holes[h].y-y,0x00f004);
			
			if(sideR==true)
			{	if(maxX-holes[h].x>0)
				{
					CreateSubBlockDemo(holes[h].x-dx_2+radius+((maxX-holes[h].x)/2), 1, (holes[h].y-y)/2+y -dy_2,maxX-holes[h].x, 1, holes[h].y-y+diam,0xf0f004);
				}			
			}
			
			if(sideL==true)
			{	if(holes[h].x-minX>0)
				{
					CreateSubBlockDemo(holes[h].x-dx_2-radius-((holes[h].x-minX)/2), 1, (holes[h].y-y)/2+y -dy_2,holes[h].x-minX, 1, holes[h].y-y+diam,0xf0f004);
				}			
			}
			if(top==true)
			{
				if(minX==45555)
					minX=holes[h].x;
				if(maxX==0)
					maxX=holes[h].x;
					
				if((minX!=45555)&&(maxX!=0))
				{
					console.log("j'ai TOP "+minX+"; "+maxX);
					Column.push({x1:minX,x2:maxX+diam});
					CreateSubBlockDemo((maxX-minX+diam)/2+minX-dx_2-radius, 1, (dy-holes[h].y-diam)/2+holes[h].y -dy_2+diam,maxX-minX+diam, 1, dy-holes[h].y,0xF0f0F4);
				}
			}
		}
		
		
		//recherche vers le bas
		for(h=0;h<holes.length;h++)
		//h=14;
		{
			var ymin=0
			var sideL=false;
			var sideR=false;
			var maxX=0;
			var minX=45555;
			for(h2=0;h2<holes.length;h2++)
			{
				if(h!=h2)
				{
				
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+diam)&& (holes[h2].y+diam<holes[h].y))//un cube en bas dans le fuseau a droite
					{
						if(holes[h2].y+diam>ymin)
							ymin=holes[h2].y+diam;
					}
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+diam)&& (holes[h2].y+diam>holes[h].y))//un cube en bas dans le fuseau a droite
					{
						//console.log("j'ai DOWN A");
						if(holes[h2].x>maxX)
						{
							maxX=holes[h2].x;
							sideR=true;
						}
						
					}
					if((holes[h2].x+diam>=holes[h].x)&&(holes[h2].x+diam<=holes[h].x+diam)&& (holes[h2].y+diam<holes[h].y))//un cube en bas dans le fuseau a gauche
					{
						if(holes[h2].y+diam>ymin)
							ymin=holes[h2].y+diam;
					}
					if((holes[h2].x+diam>=holes[h].x)&&(holes[h2].x+diam<=holes[h].x+diam)&& (holes[h2].y+diam>holes[h].y))//un cube en bas dans le fuseau a gauche
					{
						//console.log("j'ai DOWN B");
						if(holes[h2].x<minX)
						{
							minX=holes[h2].x;
							sideL=true;
						}
					}
					
				}
			}
			var block1;
			if(sideR==true)
			{	if(maxX-holes[h].x>0)
				{
					//console.log("R "+(maxX-holes[h].x)/2);
					CreateSubBlockDemo(holes[h].x-dx_2+radius+((maxX-holes[h].x)/2), 1, (holes[h].y-ymin)/2+ymin -dy_2,maxX-holes[h].x, 1, holes[h].y-ymin+diam,0x00f0f4);
				}			
			}
			
			if(sideL==true)
			{	if(holes[h].x-minX>0)
				{
					//console.log("L "+(holes[h].x-minX)/2);
					CreateSubBlockDemo(holes[h].x-dx_2-radius-((holes[h].x-minX)/2), 1, (holes[h].y-ymin)/2+ymin -dy_2,holes[h].x-minX, 1,  holes[h].y-ymin+diam,0x00f0f4);
				}			
			}
		}
		//fill between column
		Column.sort((a, b) => (a.x1 > b.x1) ? 1 : -1);
		Column.push({x1:dx+diam,x2:dx+diam});
		var prevX=0;
		for(var z=0;z<Column.length;z++)
		{
			console.log("col:"+Column[z].x1+"; "+Column[z].x2);
			if(Column[z].x1-prevX>0)
				CreateSubBlockDemo(prevX-dx_2-radius+((Column[z].x1-prevX)/2), 1, 0,Column[z].x1-prevX, 1,  dy+diam,0xf000f4);
			prevX=Column[z].x2;
		}
		
			
	}
	

		function createGround(material)
		{
			let scale = {x: 60, y: 2, z: 50};
			let mass = 0;
			let quat = {x: 0, y: 0, z: 0, w: 1};
			
			//------------------------
			/*
			var blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), material);
                blockPlane.position.set(10, 10, 10);
                blockPlane.scale.set(scale.x, scale.y, scale.z);
				const quaternion = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w);
				blockPlane.applyQuaternion(quaternion); // Apply Quaternion
                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;
				groupGround.add( blockPlane );
*/
			
			//-------------
			var shape = new THREE.Shape();
			//...define your shape
			shape.moveTo( 0,0 );
			shape.lineTo( 0, 50 );
			shape.lineTo( 60,50 );
			shape.lineTo( 60,0 );
			shape.lineTo( 0,0 );
 
			
	
			
			var h;
			for(h=0;h<holes.length;h++)
				AddHole(shape,holes[h],1.15);
						
			CreateBlockDemo(holes);
						
			const extrudeSettings = {
			  steps: 2,
			  depth: 0.5,
			  bevelEnabled: false,
			  bevelThickness: 1,
			  bevelSize: 1,
			  bevelSegments: 2,
			  material:0, //material index of the front and back face
              extrudeMaterial : 1 //material index of the side faces
			};

			//const geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
			var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
			
			//var materialSide = new THREE.MeshBasicMaterial( { color: woodcolor } );
			var mesh = new THREE.Mesh( geometry, [material,materialWood] ) ;
			mesh.rotation.x= THREE.Math.degToRad( 90 );
			mesh.position.x=-30;
			mesh.position.z=-25;
			mesh.position.y=1;
			
			mesh.castShadow = true;
            mesh.receiveShadow = true;
			//scene.add( mesh );
			groupGround.add( mesh );


			/*
			//Ammojs Section
			let transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin( new Ammo.btVector3(0, 0, 0 ) );
			transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
			//let motionState = new Ammo.btDefaultMotionState( transform );
			
			
			//var geometry2 = new THREE.Geometry().fromBufferGeometry( geometry );
			//var colShape1=getMesh(geometry2);
			//var colShape1=createTriangleShapeByGeometry(geometry2);
			
			var colShape1 = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );				
						
			
			colShape1.setMargin( 0.05 );
			let localInertia = new Ammo.btVector3( 0, 0, 0 );
			colShape1.calculateLocalInertia( mass, localInertia );
				
			//let transform2 = new Ammo.btTransform();
			//transform2.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			compoundShapeGround.addChildShape(transform, colShape1);
			*/
		}


		   function createBall(){
                
             
                let radius = ballRadius;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 2;

                //threeJS Section
				
				let ballMaterial = new THREE.MeshStandardMaterial ({color: 0xECECEC, roughness:0.2, metalness:0.8});
                ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius,20,20), ballMaterial);

                ball.position.set(posOrigin.x, posOrigin.y, posOrigin.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( posOrigin.x, posOrigin.y, posOrigin.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );
			    
	

                let localInertia = new Ammo.btVector3( 1, 1, 1 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                bodyBall = new Ammo.btRigidBody( rbInfo );

				bodyBall.setCollisionFlags( 0 );// 0 is static, 1 is dynamic, 2 is kinematic
				bodyBall.setActivationState( 4 ); // never sleep, alow physics after a stedy state period
				 
				//bodyBall.setFriction(.1);
				bodyBall.setRestitution(.6);
				//bodyBall.setDamping(0.2, 0.2);
				
                physicsWorld.addRigidBody( bodyBall, colGroupRedBall, colGroupPlane | colGroupGreenBall );
                
                ball.userData.physicsBody = bodyBall;
                rigidBodies.push(ball);
            }



            


            function updatePhysics( deltaTime ){

                // Step world
                physicsWorld.stepSimulation( deltaTime, 10 );

                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
                }

            }





	
	        function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xbfd1e5 );

                //create camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 5000 );
                //camera.position.set( 0, 30, 70 );
				camera.position.set( 0, 80, 20 );
				
                camera.lookAt(new THREE.Vector3(0, 0, 0));
				
				// create an AudioListener and add it to the camera
				listener = new THREE.AudioListener();
				camera.add( listener );

				
		
				
                //Add hemisphere light
                let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
                hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
                hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
                hemiLight.position.set( 0, 50, 0 );
                scene.add( hemiLight );

                //Add directional light
                let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                let d = 50;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;

                //Setup the renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;

                renderer.shadowMap.enabled = true;
				
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableKeys  = false;
				controls.maxDistance =200;
				controls.minDistance =30;
				controls.minPolarAngle = THREE.Math.degToRad( -45);;
				controls.maxPolarAngle = THREE.Math.degToRad( 80);;
								
				controls.update();
				

            }
			function CheckStatus()
			{

				let ms = bodyBall.getMotionState();
				// var speedVector= = new Ammo.btVector3(100,0,100); bodyBall.getLinearVelocity();
				var speedVector= bodyBall.getLinearVelocity();
				//console.log("ammoSpeedVector"+speedVector.x()+"; "+speedVector.y()+"; "+speedVector.z());
				var tjsSpeedVectorNorm= new THREE.Vector3(speedVector.x(), speedVector.y(), speedVector.z());
				var speed=tjsSpeedVectorNorm.length();
				tjsSpeedVectorNorm.normalize ();
				//console.log("ThreeSpeedVector"+tjsSpeedVectorNorm.x+"; "+tjsSpeedVectorNorm.y+"; "+tjsSpeedVectorNorm.z);
				caster.set(ball.position, tjsSpeedVectorNorm);
				var collisions;
				collisions = caster.intersectObjects(scene.children,true);
				 for ( var j = 0; j < collisions.length; j++ ) {
				   if(collisions[ j ].object!=undefined)
					  {
						  if ((collisions[j].distance >=1)&&(collisions[j].distance <=2)) {
							//collisions[ j ].object.material=new THREE.MeshPhongMaterial({color: 0x0000F0});
						  /*
							// Yep, this.rays[i] gives us : 0 => up, 1 => up-left, 2 => left, ...
							if ((i === 0 || i === 1 || i === 7) && this.direction.z === 1) {
							  this.direction.setZ(0);
							} else if ((i === 3 || i === 4 || i === 5) && this.direction.z === -1) {
							  this.direction.setZ(0);
							}
							if ((i === 1 || i === 2 || i === 3) && this.direction.x === 1) {
							  this.direction.setX(0);
							} else if ((i === 5 || i === 6 || i === 7) && this.direction.x === -1) {
							  this.direction.setX(0);
							}
							*/
							if(speed>2)
							{
								var millis = Date.now() - lastBong;
								if(millis>200)
								{
									console.log("BONG: collision comming with something at 32 in speed dir "+j+ " dist="+ collisions[j].distance+ " speed="+speed);
									lastBong=Date.now();
									if(soundEnabled==true)
										sound.play();
								}
							}
						}
					}
				 }
				
				var rays = [
					  new THREE.Vector3(0, 0, 1),
					  new THREE.Vector3(1, 0, 1),
					  new THREE.Vector3(1, 0, 0),
					  new THREE.Vector3(1, 0, -1),
					  new THREE.Vector3(0, 0, -1),
					  new THREE.Vector3(-1, 0, -1),
					  new THREE.Vector3(-1, 0, 0),
					  new THREE.Vector3(-1, 0, 1)
					  // new THREE.Vector3(0, -1, 0)//en bas
					];
					
				var  distance = 2;
				var Frotte=false;
				var i;
				 // For each ray
				for (i = 0; i < rays.length; i += 1) 
				{
				
					//console.log("loop "+ i);
				  // We reset the raycaster to this direction
				  caster.set(ball.position, rays[i]);
				  // Test if we intersect with any obstacle mesh
				  collisions = caster.intersectObjects(scene.children,true);
				  // And disable that direction if we do
				  
				  for ( var j = 0; j < collisions.length; j++ ) {
					  
					  if (collisions[j].distance <= ballRadius+0.1) {
					  
					  if(collisions[ j ].object!=undefined)
					  {
						//collisions[ j ].object.material=new THREE.MeshPhongMaterial({color: 0xF00000});
					  /*
						// Yep, this.rays[i] gives us : 0 => up, 1 => up-left, 2 => left, ...
						if ((i === 0 || i === 1 || i === 7) && this.direction.z === 1) {
						  this.direction.setZ(0);
						} else if ((i === 3 || i === 4 || i === 5) && this.direction.z === -1) {
						  this.direction.setZ(0);
						}
						if ((i === 1 || i === 2 || i === 3) && this.direction.x === 1) {
						  this.direction.setX(0);
						} else if ((i === 5 || i === 6 || i === 7) && this.direction.x === -1) {
						  this.direction.setX(0);
						}
						*/
						if(speed>2)
						{
							//console.log("ca frotte!!!! in contact with something at 32 in dir "+ i+" "+j+ " dist="+ collisions[j].distance);
							Frotte=true;
						}
					}
				  }
				}
				}
				if((Frotte==true)&&(previousFrotte==false))
				{
					previousFrotte=true;
					console.log("ca frotte!!!!");
				}else if((Frotte==false)&&(previousFrotte==true))
				{
					previousFrotte=false;
					console.log("ca frotte plus!!!!");
				}				
				
                if ( ms ) 
				{
					var inhole=false;
					ms.getWorldTransform( tmpTrans );
                    let p = tmpTrans.getOrigin();
					var bx=p.x()+30;
					var by=p.z()+25;
					var by=p.y();
					if(by>-6.5)
					{
						//console.log(by);
						//console.log("CheckStatus:"+bx+", "+by+"    "+(holes[0].x)+", "+(holes[0].y));	
						for(h=0;h<holes.length;h++)
						{
							var dist=((bx-holes[h].x)*(bx-holes[h].x)) + ((by-holes[h].y)*(by-holes[h].y));
							if(dist<1)
							{
								//console.log("dans le trou "+h+": " +holes[h].l+ "; dist="+dist);
								document.getElementById('info').innerHTML = "Lost "+h+": " +holes[h].l;//+ "; dist="+dist;
								inhole=true;
								break;
							}
						}
						var distFinish=((bx-finish.x)*(bx-finish.x)) + ((by-finish.y)*(by-finish.y));
						if(distFinish<1)
						{
							document.getElementById('info').innerHTML = "Gagné!!!";
						}
					}
					
				
				}
				if(inhole==false)
				{
					document.getElementById('info').innerHTML = Math.round(AngleX*50)+";"+Math.round(AngleZ*50)
				}
				
				
				
			}
			
        
            function renderFrame(){

                let deltaTime = clock.getDelta();

                updatePhysics( deltaTime );
				
				CheckStatus();
				controls.update();
                renderer.render( scene, camera );

                requestAnimationFrame( renderFrame );

            }
			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

        </script>
    </body>
</html>