<html>
    <head>
        <meta charset="utf-8">
        <title>Labyrinth Ball Game</title>
        <style>
            body { margin: 0; }
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/ammo.js"></script>
		<div id="info">Description</div>
        <script>
		
		//substract 3d
		//http://learningthreejs.com/blog/2011/12/10/constructive-solid-geometry-with-csg-js/
		
		
		
		//https://medium.com/@bluemagnificent/intro-to-javascript-3d-physics-using-ammo-js-and-three-js-dd48df81f591
//http://lo-th.github.io/Ammo.lab/#basketball
//https://stemkoski.github.io/Three.js/Collision-Detection.html
//file:///D:/Utilisateurs/Nous/Desktop/Dev/amo1/ammo.js-master/examples/webgl_demo_vehicle/index.html
//http://webmaestro.fr/collisions-detection-three-js-raycasting/

//terrain
//http://blog.mastermaps.com/2013/10/terrain-building-with-threejs.html
//https://grahamweldon.com/post/2012/01/3d-terrain-generation-with-three.js/
//http://kripken.github.io/ammo.js/examples/webgl_demo_terrain/index.html

//map
//http://learningthreejs.com/blog/2011/09/14/lets-make-a-3D-game-map-editor/

//Physijs/
//https://gamedevelopment.tutsplus.com/tutorials/creating-a-simple-3d-physics-game-using-threejs-and-physijs--cms-29453
//https://chandlerprall.github.io/Physijs/


//compound:
//https://github.com/kripken/ammo.js/blob/master/bullet/Demos/ConstraintDemo/ConstraintDemo.cpp
//https://gist.github.com/erwincoumans/b8a110b5c228b378161068cd25fa7d2c

            //variable declaration section
			
			
			var holes=[ {x:15.5,y:9.5,l:"1"},	{x:10.75,y:9.5,l:"2,22"},	{x:3,y:3,l:"3"},		{x:6,y:10,l:"4,5"},			{x:2.5,y:25.5,l:"6,9"},
						{x:2,y:39.5,l:"10"},	{x:6,y:35.5,l:"11"},	 	{x:5.5,y:44,l:"12"},	{x:10.75,y:40.75,l:"13"},	{x:15.25,y:46.75,l:"14,33"},
						{x:15.5,y:34.5,l:"15"},	{x:11.25,y:30.5,l:"8,16"},	{x:16,y:25.5,l:"17,20"},{x:11,y:22,l:"7,21"},		{x:14.75,y:16.5,l:"23"},
						{x:20.25,y:34.5,l:"18,31"},{x:21,y:17.75,l:"19"},	{x:30.5,y:6.85,l:"24,26"},{x:25.75,y:17,l:"25,28"},{x:31,y:26,l:"27,29,49"},
						{x:30.5,y:38.5,l:"30,36"},{x:25.25,y:43.75,l:"32,34"},{x:35.5,y:47.75,l:"35,39"},{x:35.75,y:42.5,l:"37"},{x:35.35,y:34.85,l:"38,48"},
						{x:35.85,y:18,l:"50"},{x:36.5,y:12,l:"54"},{x:36.75,y:2.75,l:"55"},{x:46.5,y:2.25,l:"56"},{x:52.5,y:2,l:"57"},{x:56.5,y:6.75,l:"58,60"},
						{x:46.5,y:12.25,l:"53"},{x:52,y:19.5,l:"45,59"},{x:45.75,y:21.5,l:"46,52"},{x:40.65,y:22.75,l:"51"},{x:45.75,y:38.5,l:"41,47"},
						{x:51,y:37,l:"42"},{x:51,y:46.25,l:"40"},{x:55.5,y:43,l:"43"},{x:55.5,y:32.5,l:"44"}
						];
			
            let physicsWorld, scene, camera, renderer, rigidBodies = [];
            let colGroupPlane = 1, colGroupRedBall = 2, colGroupGreenBall = 4

			var woodcolor=0x521C1A;
			var materialWood;
			var BlockBody;
			var compoundShape;
			var bodyBall; 
			
			
			
			var AngleZ=0;
			var AngleX=0;
document.addEventListener("keydown", onDocumentKeyDown, false);
function onDocumentKeyDown(event) {
    var keyCode = event.which;
	//var delta=0.005;
	var delta=0.02;
	//console.log("key pressed" +keyCode);
    if (keyCode == 38) {
                rotateX(-delta);
    } else if (keyCode == 40) {
                rotateX(delta)
    } else if (keyCode == 39) {
        rotateZ(-delta);
    } else if (keyCode == 37) {
        rotateZ(delta);
    } else if (keyCode == 32) {
        //blockPlane.position.set(0, 0, 0);
    
	} else if (keyCode == 65) {//a
		console.log("apply force");
		//apply force
		var relativeForce = new Ammo.btVector3(100,0,100);
		//btTransform* boxTrans;
		//boxRigidBody->getMotionState()->getWroldTransform(boxTrans);
		//btVector3 correctedForce = (boxTrans * relativeForce) - boxTrans.getOrigin();
		bodyBall.applyCentralForce(relativeForce);
    }
};


// obj - your object (THREE.Object3D or derived)
// point - the point of rotation (THREE.Vector3)
// axis - the axis of rotation (normalized THREE.Vector3)
// theta - radian value of rotation
// pointIsWorld - boolean indicating the point is in world coordinates (default = false)
function rotateAboutPoint(obj, point, axis, theta, pointIsWorld){
    pointIsWorld = (pointIsWorld === undefined)? false : pointIsWorld;

    if(pointIsWorld){
        obj.parent.localToWorld(obj.position); // compensate for world coordinate
    }

    obj.position.sub(point); // remove the offset
    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION
    obj.position.add(point); // re-add the offset

    if(pointIsWorld){
        obj.parent.worldToLocal(obj.position); // undo world coordinates compensation
    }

    obj.rotateOnAxis(axis, theta); // rotate the OBJECT
}

function rotateZ(deltaZ) {

		var myAxis = new THREE.Vector3(0, 0, 1);
		AngleZ=AngleZ+deltaZ;
		console.log("key pressed" +AngleX+", "+AngleZ);
		rotateXZ()
}

function rotateX(deltaX) {

		var myAxis = new THREE.Vector3(1, 0, 0);
		AngleX=AngleX+deltaX;
		console.log("key pressed" +AngleX+", "+AngleZ);
	 rotateXZ() 
}
function rotateXZ() {
		let pos = {x: 0, y: 0, z: 0};
		let transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
        transform.setRotation( new Ammo.btQuaternion( AngleX, 0, AngleZ, 1 ) );
				
        BlockBody.setWorldTransform(transform);
        BlockBody.setLinearVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
        BlockBody.setAngularVelocity(new Ammo.btVector3(0.0, 0.0, 0.0));
	
		let p = transform.getOrigin();
		let q = transform.getRotation();
		group.position.set( p.x(), p.y(), p.z() );
		group.quaternion.set( q.x(), q.y(), q.z(), q.w() );
}

			
            //Ammojs Initialization
            Ammo().then(start)

            function start (){


                tmpTrans = new Ammo.btTransform();

                setupPhysicsWorld();
				setupGraphics();
				
				group = new THREE.Group();
                compoundShape = new Ammo.btCompoundShape();
				
				
				
				var loader = new THREE.TextureLoader();
				var texture1 =loader.load('img/Background.jpg');
				console.log("texture="+texture1);
				texture1.wrapS = texture1.wrapT = THREE.RepeatWrapping;
				texture1.repeat.set( 1/60, -1/50 );
				var materialBase = new THREE.MeshBasicMaterial( {map: texture1 } );
				var texture2 =loader.load('img/wood.jpg');
				materialWood = new THREE.MeshBasicMaterial( {map: texture2 } );
				
				createGround(materialBase);
				//createWalls();
				scene.add( group );
								
				var mass=0;
				let localInertia = new Ammo.btVector3( 0, 0, 0 );
				compoundShape.calculateLocalInertia(mass,localInertia);
				let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, 0, compoundShape, localInertia );
				BlockBody = new Ammo.btRigidBody( rbInfo );
			  
				BlockBody.setFriction(.1);
				BlockBody.setRestitution(.8);
				BlockBody.setDamping(0.2, 0.2);
				BlockBody.setCollisionFlags( 1 );// 0 is static, 1 is dynamic, 2 is kinematic
				BlockBody.setActivationState( 4 );//never sleep

				physicsWorld.addRigidBody( BlockBody, colGroupPlane, colGroupRedBall );
				
                createBall();
                //createMaskBall();

                renderFrame();
			
            }

            function setupPhysicsWorld(){

                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -20, 0));//2g to speed up the gameplay

            }




/*
            function createBlock(pos,scale){
                
                //let pos = {x: 0, y: 0, z: 0};
                //let scale = {x: 50, y: 2, z: 50};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 0;

                //threeJS Section
				var blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa0afa4}));
                blockPlane.position.set(pos.x, pos.y, pos.z);
                blockPlane.scale.set(scale.x, scale.y, scale.z);
				const quaternion = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w);
				blockPlane.applyQuaternion(quaternion); // Apply Quaternion
                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;
				group.add( blockPlane );

                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                //let motionState = new Ammo.btDefaultMotionState( transform );
                var colShapePlane = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
                colShapePlane.setMargin( 0.05 );
                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShapePlane.calculateLocalInertia( mass, localInertia );
				
				//let transform2 = new Ammo.btTransform();
				//transform2.setIdentity();
				//transform2.setOrigin(new Ammo.btVector3(0, 0, 0));
				compoundShape.addChildShape(transform, colShapePlane);
				
            }
*/


		function createWalls()
		{
			//createBlock( {x: 0, y: 0, z: 0},   {x: 50, y: 2, z: 50});
			createBlock({x: 0, y: 2, z: -26},{x: 62, y: 6, z: 2});
			createBlock({x: 0, y: 2, z: 26},{x: 62, y: 6, z: 2});
			createBlock({x: -31, y: 2, z: 0},{x: 2, y: 6, z: 54});
			createBlock({x: 31, y: 2, z: 0},{x: 2, y: 6, z: 54});
				
			createWall_y(4,-14,23);//grand vertical pres du start
			createWall_x(-3.5,-21,16);//grand horizontal sous le start
			createWall_y(-11,-18.5,5.5);//au bout du precedent
			createWall_y(-16,-23,5);//en face du start
			createWall_y(-16.5,-16,4);//en dessous du precedent
			createWall_y(-21.5,-18.5,4);//entre 2 et 4
			createWall_x(-28,-19,4.5);//sous le 3
			createWall_x(-28,-9.5,4.5);//en desous du precedent
			createWall_y(-21,-8.75,8);//entre 5 et 22
			createWall_x(-23,-5.25,5);//ptres du 7
			createWall_y(-25,2,4);//pres du 6 et du 9
			createWall_y(-21,2,4);//au dessus du 8
		}

		function createWallExtrude()
		{
			var shape = new THREE.Shape();
			//...define your shape
			shape.moveTo( 10,10 );
			shape.lineTo( 10, 12 );
			shape.absarc(10.25, 12, 0.25, 0, Math.PI*2 , false);
			
			//shape.lineTo( 10.5,12 );
			shape.lineTo( 10.5,10 );
			shape.lineTo( 10,10 );
			
			const extrudeSettings = {
			  steps: 2,
			  depth: 30,
			  bevelEnabled: false,
			  bevelThickness: 1,
			  bevelSize: 1,
			  bevelSegments: 2,
			};
			
			var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
			
			
			var mesh = new THREE.Mesh( geometry, materialWood) ;
			mesh.rotation.x= THREE.Math.degToRad( 0 );
			mesh.position.x=-30;
			mesh.position.z=-25;
			mesh.position.y=5;
			
			mesh.castShadow = true;
            mesh.receiveShadow = true;
			//scene.add( mesh );
			group.add( mesh );
			
		}
		function createWall_x(pos_x,pos_z,len)
		{
			createBlock2({x: pos_x, y: 2, z: pos_z},{x: len, y: 1, z: 1},2);
		}
		
		function createWall_y(pos_x,pos_z,len)
		{
			createBlock2({x: pos_x, y: 2, z: pos_z},{x: 1, y: 1, z: len},2);
		}
		
		function createBlock(pos,scale)
		{
			createBlock2(pos,scale,1);
		}
		
	     function createBlock2(pos,scale, type){
                
            let quat = {x: 0, y: 0, z: 0, w: 1};
            let mass = 0;

            //threeJS Section
			var block1;
			if(type==1)
				block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), materialWood);
			else
				block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa0afa4}));
				
                block1.position.set(pos.x, pos.y, pos.z);
                block1.scale.set(scale.x, scale.y, scale.z);
				const quaternion = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w);
				block1.applyQuaternion(quaternion); // Apply Quaternion
                block1.castShadow = true;
                block1.receiveShadow = true;
				group.add( block1 );

                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                //let motionState = new Ammo.btDefaultMotionState( transform );
                var colShape1 = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
                colShape1.setMargin( 0.05 );
                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape1.calculateLocalInertia( mass, localInertia );
					
				//let transform2 = new Ammo.btTransform();
				//transform2.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
				compoundShape.addChildShape(transform, colShape1);
				
            }

		
		function AddHole(shape,hole,radius){

			var ox=hole.x;
			var oy=hole.y;
			
			var circleTri = new THREE.Shape();
			var circle = new THREE.Shape();
			var segments = 32;
			var theta, x, y;
			for (var i = 0; i < segments; i++) {
				theta = ((i + 1) / segments) * Math.PI * 2.0;
				x = radius * Math.cos(theta);
				y = radius * Math.sin(theta);
				if (i == 0) {
					circle.moveTo(x+ox, y+oy);
				} else {
					circle.lineTo(x+ox, y+oy);
				}
			}
			shape.holes.push( circle );
		}

	function CreateBlockDemo(holes)
	{
		var h;
		for(h=0;h<holes.length;h++)
		//h=14;
		{
			var block1;
			block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa00f04}));
			block1.position.set(holes[h].x-30, 1, holes[h].y-25);
			block1.scale.set(2.30, 1, 2.30);
			group.add( block1 );
		}
		
		//recherche vers le haut
		for(h=0;h<holes.length;h++)
		//h=14;
		{
			var y=0;
			var sideL=0;
			var sideR=0;
			var maxX=0;
			var minX=45555;
			var top=true;
			for(h2=0;h2<holes.length;h2++)
			{
				if(h!=h2)
				{
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+2.3)&& (holes[h2].y+2.3>holes[h].y))//en cube en haut dand le fuseau a droite
					{
						top=false;
					}
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+2.3)&& (holes[h2].y+2.3<holes[h].y))//en cube en haut dand le fuseau a droite
					{
						if(holes[h2].x>maxX)
						{
							maxX=holes[h2].x;
							sideR=1;
						}
						if(holes[h2].y+2.3>y)
						{
							y=holes[h2].y+2.3;
							//console.log("j'ai UP+1"+y);
						}
					}
					if((holes[h2].x+2.3>=holes[h].x)&&(holes[h2].x+2.3<=holes[h].x+2.3)&& (holes[h2].y+2.3>holes[h].y))//en cube en haut dand le fuseau a droite
					{
						top=false;
					}
					if((holes[h2].x+2.3>=holes[h].x)&&(holes[h2].x+2.3<=holes[h].x+2.3)&& (holes[h2].y+2.3<holes[h].y))//en cube en haut dans le fuseau a gauche
					{
						if(holes[h2].x<minX)
						{
							minX=holes[h2].x;
							sideL=-1;
						}
						if(holes[h2].y+2.3>y)
						{
							y=holes[h2].y+2.3;
						//	console.log("j'ai UP-1 "+y);
						}
					}
				}
			}
			var block1;
			block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x00f004}));
			block1.position.set(holes[h].x-30, 1, (holes[h].y-y)/2+y -25-1.15);
			block1.scale.set(2.30, 1, holes[h].y-y);
			group.add( block1 );
			
			if(sideR==1)
			{	if(maxX-holes[h].x>0)
				{
					//console.log("R "+(maxX-holes[h].x)/2);
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf0f004}));
					block1.position.set(holes[h].x-30+1.15+((maxX-holes[h].x)/2), 1, (holes[h].y-y)/2+y -25);
					block1.scale.set((maxX-holes[h].x), 1, holes[h].y-y+2.30);
					group.add( block1 );
				}			
			}
			
			if(sideL==-1)
			{	if(holes[h].x-minX>0)
				{
					//console.log("L "+(holes[h].x-minX)/2);
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf0f004}));
					block1.position.set(holes[h].x-30-1.15-((holes[h].x-minX)/2), 1, (holes[h].y-y)/2+y -25);
					block1.scale.set((holes[h].x-minX), 1, holes[h].y-y+2.30);
					group.add( block1 );
				}			
			}
			if(top==true)
			{
				if(minX==45555)
					minX=holes[h].x;
				if(maxX==0)
					maxX=holes[h].x;
					
				if((minX!=45555)&&(maxX!=0))
				{
					console.log("j'ai TOP "+minX+"; "+maxX);
					
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xF0f0F4}));
					block1.position.set((maxX-minX+2.3)/2+minX-30-1.15, 1, (50-holes[h].y-2.3)/2+holes[h].y -25+1.15);
					block1.scale.set(maxX-minX+2.3, 1, 50-holes[h].y-2.3);
					group.add( block1 );
				}
			}
			
			
		}
		
		
		
		//recherche vers le bas
		for(h=0;h<holes.length;h++)
		//h=14;
		{
			var ymin=0
			var yL=0;
			var yR=0;
			var sideL=0;
			var sideR=0;
			var maxX=0;
			var minX=45555;
			for(h2=0;h2<holes.length;h2++)
			{
				if(h!=h2)
				{
				
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+2.3)&& (holes[h2].y+2.3<holes[h].y))//un cube en bas dans le fuseau a droite
					{
						if(holes[h2].y+2.3>ymin)
							ymin=holes[h2].y+2.3;
					}
					if((holes[h2].x>=holes[h].x)&&(holes[h2].x<=holes[h].x+2.3)&& (holes[h2].y+2.3>holes[h].y))//un cube en bas dans le fuseau a droite
					{
						//console.log("j'ai DOWN A");
						if(holes[h2].x>maxX)
						{
							maxX=holes[h2].x;
							sideR=1;
							yR=holes[h2].y;
						}
						
					}
					if((holes[h2].x+2.3>=holes[h].x)&&(holes[h2].x+2.3<=holes[h].x+2.3)&& (holes[h2].y+2.3<holes[h].y))//un cube en bas dans le fuseau a gauche
					{
						if(holes[h2].y+2.3>ymin)
							ymin=holes[h2].y+2.3;
					}
					if((holes[h2].x+2.3>=holes[h].x)&&(holes[h2].x+2.3<=holes[h].x+2.3)&& (holes[h2].y+2.3>holes[h].y))//un cube en bas dans le fuseau a gauche
					{
						//console.log("j'ai DOWN B");
						if(holes[h2].x<minX)
						{
							minX=holes[h2].x;
							sideL=-1;
							yL=holes[h2].y;
						}
					}
					
				}
			}
			var block1;
			if(sideR==1)
			{	if(maxX-holes[h].x>0)
				{
					//console.log("R "+(maxX-holes[h].x)/2);
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x00f0f4}));
					block1.position.set(holes[h].x-30+1.15+((maxX-holes[h].x)/2), 1, (holes[h].y-ymin)/2+ymin -25);
					block1.scale.set((maxX-holes[h].x), 1, holes[h].y-ymin+2.3);
					group.add( block1 );
				}			
			}
			
			if(sideL==-1)
			{	if(holes[h].x-minX>0)
				{
					//console.log("L "+(holes[h].x-minX)/2);
					block1 = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x00f0f4}));
					block1.position.set(holes[h].x-30-1.15-((holes[h].x-minX)/2), 1, (holes[h].y-ymin)/2+ymin -25);
					block1.scale.set((holes[h].x-minX), 1,  holes[h].y-ymin+2.3);
					group.add( block1 );
				}			
			}
			
			
		}
		
		
			
	}

		function createGround(material)
		{
			let scale = {x: 60, y: 2, z: 50};
			let mass = 0;
			let quat = {x: 0, y: 0, z: 0, w: 1};
			
			//------------------------
			/*
			var blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), material);
                blockPlane.position.set(10, 10, 10);
                blockPlane.scale.set(scale.x, scale.y, scale.z);
				const quaternion = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w);
				blockPlane.applyQuaternion(quaternion); // Apply Quaternion
                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;
				group.add( blockPlane );
*/
			
			//-------------
			var shape = new THREE.Shape();
			//...define your shape
			shape.moveTo( 0,0 );
			shape.lineTo( 0, 50 );
			shape.lineTo( 60,50 );
			shape.lineTo( 60,0 );
			shape.lineTo( 0,0 );
 
			
	
			
			var h;
			for(h=0;h<holes.length;h++)
				AddHole(shape,holes[h],1.15);
						
			CreateBlockDemo(holes);
						
			const extrudeSettings = {
			  steps: 2,
			  depth: 0.5,
			  bevelEnabled: false,
			  bevelThickness: 1,
			  bevelSize: 1,
			  bevelSegments: 2,
			  material:0, //material index of the front and back face
              extrudeMaterial : 1 //material index of the side faces
			};

			//const geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
			var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
			
			var materialSide = new THREE.MeshBasicMaterial( { color: 0x521C1A } );
			var mesh = new THREE.Mesh( geometry, [material,materialSide] ) ;
			mesh.rotation.x= THREE.Math.degToRad( 90 );
			mesh.position.x=-30;
			mesh.position.z=-25;
			mesh.position.y=1;
			
			mesh.castShadow = true;
            mesh.receiveShadow = true;
			//scene.add( mesh );
			group.add( mesh );


			
			//Ammojs Section
			let transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin( new Ammo.btVector3(0, 0, 0 ) );
			transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
			//let motionState = new Ammo.btDefaultMotionState( transform );
			
			
			//var geometry2 = new THREE.Geometry().fromBufferGeometry( geometry );
			//var colShape1=getMesh(geometry2);
			//var colShape1=createTriangleShapeByGeometry(geometry2);
			
			var colShape1 = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );				
						
			
			colShape1.setMargin( 0.05 );
			let localInertia = new Ammo.btVector3( 0, 0, 0 );
			colShape1.calculateLocalInertia( mass, localInertia );
				
			//let transform2 = new Ammo.btTransform();
			//transform2.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			compoundShape.addChildShape(transform, colShape1);
		}


		   function createBall(){
                
                let pos = {x: 2, y: 10, z: -23};
                let radius = 1;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 2;

                //threeJS Section
				
				let ballMaterial = new THREE.MeshStandardMaterial ({color: 0xECECEC, roughness:0.2, metalness:0.8});
                let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius,20,20), ballMaterial);

                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius*1.0 );
                colShape.setMargin( 0.05 );
			    
	

                let localInertia = new Ammo.btVector3( 1, 1, 1 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                bodyBall = new Ammo.btRigidBody( rbInfo );

				bodyBall.setCollisionFlags( 0 );// 0 is static, 1 is dynamic, 2 is kinematic
				bodyBall.setActivationState( 4 ); // never sleep, alow physics after a stedy state period
				 
				//bodyBall.setFriction(.1);
				bodyBall.setRestitution(.6);
				//bodyBall.setDamping(0.2, 0.2);
				
                physicsWorld.addRigidBody( bodyBall, colGroupRedBall, colGroupPlane | colGroupGreenBall );
                
                ball.userData.physicsBody = bodyBall;
                rigidBodies.push(ball);
            }



            


            function updatePhysics( deltaTime ){

                // Step world
                physicsWorld.stepSimulation( deltaTime, 10 );

                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
                }

            }



//https://stackoverflow.com/questions/39441459/rigid-body-shape-in-bullet-ammo-js-from-a-mesh-in-three-js

//

function createTriangleShapeByGeometry(geometry) {
    var mesh = new Ammo.btTriangleMesh(true, true);
    var vertices = geometry.vertices;
    for (var i = 0; i < geometry.faces.length; i++) {
        var face = geometry.faces[i];
        if (face instanceof THREE.Face3) {
            mesh.addTriangle(
                new Ammo.btVector3(vertices[face.a].x, vertices[face.a].y, vertices[face.a].z),
                new Ammo.btVector3(vertices[face.b].x, vertices[face.b].y, vertices[face.b].z),
                new Ammo.btVector3(vertices[face.c].x, vertices[face.c].y, vertices[face.c].z),
                false
            );
        } else if (face instanceof THREE.Face4) {
            mesh.addTriangle(
                new Ammo.btVector3(vertices[face.a].x, vertices[face.a].y, vertices[face.a].z),
                new Ammo.btVector3(vertices[face.b].x, vertices[face.b].y, vertices[face.b].z),
                new Ammo.btVector3(vertices[face.d].x, vertices[face.d].y, vertices[face.d].z),
                false
            );
            mesh.addTriangle(
                new Ammo.btVector3(vertices[face.b].x, vertices[face.b].y, vertices[face.b].z),
                new Ammo.btVector3(vertices[face.c].x, vertices[face.c].y, vertices[face.c].z),
                new Ammo.btVector3(vertices[face.d].x, vertices[face.d].y, vertices[face.d].z),
                false
            );
        }
    }
    var shape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
    return shape;
}


function getMesh( geometry ) {

		var i,
			width, height, depth,
			vertices, face, triangles = [];
			geometry.elementsNeedUpdate=true;
			console.log(geometry.faces);
			vertices = geometry.vertices;
			for ( i = 0; i < geometry.faces.length; i++ ) {
				face = geometry.faces[i];
				if ( face instanceof THREE.Face3) {

					triangles.push([
						{ x: vertices[face.a].x, y: vertices[face.a].y, z: vertices[face.a].z },
						{ x: vertices[face.b].x, y: vertices[face.b].y, z: vertices[face.b].z },
						{ x: vertices[face.c].x, y: vertices[face.c].y, z: vertices[face.c].z }
					]);

				} else if ( face instanceof THREE.Face4 ) {

					triangles.push([
						{ x: vertices[face.a].x, y: vertices[face.a].y, z: vertices[face.a].z },
						{ x: vertices[face.b].x, y: vertices[face.b].y, z: vertices[face.b].z },
						{ x: vertices[face.d].x, y: vertices[face.d].y, z: vertices[face.d].z }
					]);
					triangles.push([
						{ x: vertices[face.b].x, y: vertices[face.b].y, z: vertices[face.b].z },
						{ x: vertices[face.c].x, y: vertices[face.c].y, z: vertices[face.c].z },
						{ x: vertices[face.d].x, y: vertices[face.d].y, z: vertices[face.d].z }
					]);

				}
			}
		var triangle, triangle_mesh = new Ammo.btTriangleMesh;
		
			
		var _vec3_1 = new Ammo.btVector3(0,0,0);
		var _vec3_2 = new Ammo.btVector3(0,0,0);
		var _vec3_3 = new Ammo.btVector3(0,0,0);
	
		for ( i = 0; i < triangles.length; i++ ) {
				triangle = triangles[i];

				_vec3_1.setX(triangle[0].x);
				_vec3_1.setY(triangle[0].y);
				_vec3_1.setZ(triangle[0].z);

				_vec3_2.setX(triangle[1].x);
				_vec3_2.setY(triangle[1].y);
				_vec3_2.setZ(triangle[1].z);

				_vec3_3.setX(triangle[2].x);
				_vec3_3.setY(triangle[2].y);
				_vec3_3.setZ(triangle[2].z);

				triangle_mesh.addTriangle(
					_vec3_1,
					_vec3_2,
					_vec3_3,
					true
				);
			}

			shape = new Ammo.btBvhTriangleMeshShape(
				triangle_mesh,
				true,
				true
			);
			return shape;
	}
	
	
	            function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xbfd1e5 );

                //create camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 5000 );
                //camera.position.set( 0, 30, 70 );
				camera.position.set( 0, 80, 20 );
				
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                //Add hemisphere light
                let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
                hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
                hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
                hemiLight.position.set( 0, 50, 0 );
                scene.add( hemiLight );

                //Add directional light
                let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                let d = 50;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;

                //Setup the renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;

                renderer.shadowMap.enabled = true;

            }
			function CheckStatus()
			{
				var inhole=false;
				let ms = bodyBall.getMotionState();
                if ( ms ) 
				{
					ms.getWorldTransform( tmpTrans );
                    let p = tmpTrans.getOrigin();
					var bx=p.x()+30;
					var by=p.z()+25;
					//console.log("CheckStatus:"+bx+", "+by+"    "+(holes[0].x)+", "+(holes[0].y));	
					for(h=0;h<holes.length;h++)
					{
						var dist=((bx-holes[h].x)*(bx-holes[h].x)) + ((by-holes[h].y)*(by-holes[h].y))
						if(dist<1)
						{
							//console.log("dans le trou "+h+": " +holes[h].l+ "; dist="+dist);
							document.getElementById('info').innerHTML = "Lost "+h+": " +holes[h].l;//+ "; dist="+dist;
							inhole=true;
							break;
						}
					}
				}
				if(inhole==false)
				{
					document.getElementById('info').innerHTML = Math.round(AngleX*50)+";"+Math.round(AngleZ*50)
				}
			}
			
        
            function renderFrame(){

                let deltaTime = clock.getDelta();

                updatePhysics( deltaTime );
				
				CheckStatus();

                renderer.render( scene, camera );

                requestAnimationFrame( renderFrame );

            }
			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

        </script>
    </body>
</html>